# -*- ii: enabled; -*-
#+TITLE: iiorgmacs

* Introduction

ii brings a number of technologies together to create an open workflow.
Using docker will reduce the setup and maintenance of sharing the core components with others.

* Core Components

- [[http://spacemacs.org/][Spac(emacs)]]
- [[https://orgmode.org/][Orgmode]]
- [[https://gitlab.com/oer/oer-reveal][oer-reveal]]

* Build

The [[https://gitlab.ii.coop/ii/tooling/iiorgmacs/blob/master/Dockerfile][Dockerfile]] uses [[https://gitlab.ii.coop/ii/tooling/iibase/blob/master/Dockerfile][iibase]] as its initial build stage.

#+BEGIN_SRC tmate
docker build -t iimacs/orgmacs .
#+END_SRC

* Usage
Recommended usage is with [[https://gitlab.ii.coop/ii/tooling/iitoolbox][iitoolbox]].

* Test Image as User ii

#+BEGIN_SRC tmate
docker run --name=iiorgmacs --hostname=iiorgmacs --rm -it iimacs/orgmacs
#+END_SRC

* Test Image as root User

#+BEGIN_SRC tmate
docker run --name=iiorgmacs --hostname=iiorgmacs --rm -it -u 0:0 iimacs/orgmacs
#+END_SRC

* Debug image with strace

#+BEGIN_SRC tmate
docker run --cap-add=SYS_PTRACE \
           --security-opt seccomp=unconfined \
           --name=iiorgmacs-$USER \
           --hostname=iiorgmacs \
           --rm -it -u 0:0 iiorgmacs
#+END_SRC
* Running in k8s
** Create a cluster-admin service-account
   #+begin_src shell :noweb yes :wrap "src yaml"
     cat <<EOF | kubectl apply -f -
     apiVersion: v1
     kind: ServiceAccount
     metadata:
       name: admin-iimacs
       namespace: default
     ---
     apiVersion: rbac.authorization.k8s.io/v1
     kind: ClusterRoleBinding
     metadata:
       name: admin-iimacs
     roleRef:
       apiGroup: rbac.authorization.k8s.io
       kind: ClusterRole
       name: cluster-admin
     subjects:
     - kind: ServiceAccount
       name: admin-iimacs
       namespace: default
     EOF
   #+end_src

   #+RESULTS:
   #+begin_src yaml
   serviceaccount/admin-iimacs created
   clusterrolebinding.rbac.authorization.k8s.io/admin-iimacs configured
   #+end_src

** Creating the k8macs Pod
   #+begin_src shell
     IIMAGE=gcr.io/apisnoop/iimacs:0.9.10
     PODNAME=kmacs
     kubectl run --generator=run-pod/v1 $PODNAME --serviceaccount='admin-iimacs' --image=$IIMAGE
   #+end_src
   
** Attaching to the Pod
   #+begin_src shell
     PODNAME=k8macs
     kubectl exec -t -i $PODNAME -- attach
   #+end_src
* dev-build loop
  #+begin_src shell
  IIDE=iimacs:0.9.10
  PODNAME=k8macs
  docker build -t $IIDE .
  kind load docker-image $IIDE
  kubectl run --generator=run-pod/v1 $PODNAME --serviceaccount='admin-iimacs' --image=$IIDE
  kubectl exec -t -i $PODNAME -- attach # osc52 will be sent with tmate url / you can have multiple of these
  #+end_src
* Script to connect to a remote box and configure your kubeconfig
  #+begin_src shell
    # configuration
    export KUBECONFIG=~/.kube/config-my-remote
    # [IMPORTANT] set your user
    REMOTE_USER=root
    # [IMPORTANT] set your remote box's IP
    REMOTE_HOST=x.x.x.x

    # fetch the remote kubeconfig
    ssh $REMOTE_USER@$REMOTE_HOST kubectl config view --merge --minify --flatten > $KUBECONFIG

    # find the port of the Kubernetes API in the kubeconfig and export it
    export K8S_REMOTE_PORT=$(kubectl config view -o jsonpath='{.clusters[0].cluster.server}' | cut -d ':' -f3)
    # forward the port from the remote box to the localhost
    ssh -fN -L $K8S_REMOTE_PORT:localhost:$K8S_REMOTE_PORT $REMOTE_USER@$REMOTE_HOST
  #+end_src

  #+begin_src shell
  kubectl get pods -A
  #+end_src

**  Add a helper function to your ~/.bashrc
  | Name          | Purpose                           | Example                  |
  |---------------+-----------------------------------+--------------------------|
  | ~KUBECONFIG~  | the kubeconfig to save to and use | ~/.kube/config-my-remote |
  | ~REMOTE_USER~ | the remote user to login as       | ii                       |
  | ~REMOTE_HOST~ | the remote host/ip to connect to  | myhost.example.com       |
  |---------------+-----------------------------------+--------------------------|
  #+begin_src shell
    cat << EOF >> ~/.bashrc
    function ii_setup_k8s_from_remote() {
    # ensure:
    # - remote server kubeconfig
    # - defined $KUBECONFIG
    # - remote server Kubernetes API forwarded to localhost

    function ii_setup_k8s_from_remote_cleanup() {
      set +e
    }

    trap ii_setup_k8s_from_remote_cleanup EXIT

    set -e

    if [ -x /tmp/ii_setup_k8s_from_remote-hasrun ]; then
            return
    fi

    # configuration
    if [ -z \$KUBECONFIG ]; then
      export KUBECONFIG=~/.kube/config-my-remote
    fi

    # [IMPORTANT] set your user
    if [ -z \$REMOTE_USER ]; then
       echo "[error] please set \\\$REMOTE_USER"
       return
    fi

    # [IMPORTANT] set your remote box's IP
    if [ -z \$REMOTE_HOST ]; then
       echo "[error] please set \\\$REMOTE_HOST"
       return
    fi

    # fetch the remote kubeconfig
    ssh \$REMOTE_USER@\$REMOTE_HOST kubectl config view --merge --minify --flatten > \$KUBECONFIG

    # find the port of the Kubernetes API in the kubeconfig and export it
    export K8S_REMOTE_PORT=\$(kubectl config view -o jsonpath='{.clusters[0].cluster.server}' | cut -d ':' -f3)

    # check if not already listening
    if ! lsof -i:\$K8S_REMOTE_PORT 2>&1 > /dev/null; then
      # forward the port from the remote box to the localhost
      ssh -fN -L \$K8S_REMOTE_PORT:localhost:\$K8S_REMOTE_PORT \$REMOTE_USER@\$REMOTE_HOST
    fi

    echo "[ok]"
    touch /tmp/ii_setup_k8s_from_remote-hasrun
    ii_setup_k8s_from_remote_cleanup

    }
    EOF

  #+end_src

